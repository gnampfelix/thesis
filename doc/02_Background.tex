% !TEX root = thesis.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Background}
  \label{sec:background}

For this thesis, several experiments and analysises were conducted involving
Mash, FracMinHash, phylogenetic trees and phylogenetic outlines using genomic
sequences of \textit{Phytophthora}. This chapter aims to introduce those
concepts such that the experiments and analyses can be better understood.

\section{Phylogenetic trees and phylogenetic outlines}
Phylogenetic trees visualize evolutionary relationship between different taxa.
Such a tree can be rooted and is typically bifurcating, i.e. each internal node
has exactly two children. Leaves of that tree are labelled by the set of taxa
and the tree edges are usually drawn to scale, i.e. evolutionary distances are
represented by edge lengths. Formally, let $X$ be a set of $n$ taxa. A
phylogenetic tree $T = (V, E)$ with the nodes $V$ and the edges $E$ on $X$ is a
tree of which the leaves are bijectively labeled by $X$
\cite{scornavaccaPhylogeneticTrees2010}. Internal nodes are usually not labeled.
One way to calculate a rooted phylogenetic tree for $X$ using a distance matrix
$D$ is Neighbor-Joining \cite{saitouNeighborjoiningMethodNew1987} by iteratively
linking two nodes with a new parent node. Briefly, Neighbor-Joining starts with
the star configuration, i.e. all taxa are represented by a leaf node and all
nodes are linked only to the central root node. Then, two nodes $v$ and $w$ are
selected such that their distance is minimal and the distance to all other nodes
is maximal. They are linked together by a new parent node $p$, which replaces
$v$ and $w$ in the distance matrix. This process is repeated until only one
entry remains in the distance matrix. An example tree can be seen in
Figure~\ref{fig:exampleTree}.

To serialize a tree, one could use the Newick format
\cite{pavlopoulosReferenceGuideTree2010}. In this format, leaves are represented
by their label, siblings are separated by comma. A tree is put in to
parantheses, the same applies for subtrees. Two sibling subtrees are thus also
separated by comma. The format supports the inclusion of edge lengths by putting
them after a double colon after the subtree or leaf. This thesis mostly focusses
on topology and less on actual edge lengths, so those won't be included in any
given Newick string. The tree depicted in Figure~\ref{fig:exampleTree}
serialized to Newick looks like this:

\texttt{((A, B), C)}

This tree also enables an intuitive perspective on the concept of a
\textit{split}: a split $S$ separates $X$ into two parts. In the case of
phylogenetic trees, each edge in the tree is thus a split. Formally, a split is
a biparition $S=A|B$ with $A, B \subset X$ such that $A \neq \emptyset$, $B \neq
\emptyset$, $A \cap B = \emptyset$ and $A \cup B = X$
\cite{scornavaccaSplitsUnrootedPhylogenetic2010}.

The \textit{weight} of a split $\omega(S)$ is also directly depicted in the tree
as the length of the edge. 

\begin{figure}
  \centering
    \begin{tikzpicture}[node distance={10mm}, minimum size={2mm}, inner
      sep={0pt}, thick, main/.style = {draw, circle, fill},
      color_edge/.style = {color=cyan}]
      \node[](l0){};
      \node[below = of l0](l1){};
      \node[below = of l1](l2){};
      \node[below = of l2](l3){};

      \node[main, right = 10mm of l0](root){};
      \node[main, right = 10mm of l1](abc){} edge(root);
      \node[main, right = 5mm of l2] (ba){} edge(abc);
      \node[right = 0mm of l3] (b) {B} edge(ba);
      \node[right = 10mm of l3](a) {A} edge(ba);
      \node[right = 20mm of l3] (c) {C} edge[color_edge](abc);
    \end{tikzpicture}
  \caption[Example of a rooted phylogenetic tree]{Example of a rooted
  phylogenetic tree on the taxa $X = \{A, B, C\}$. The leaves are labeled with
  the taxa, the internal nodes don't have labels. Each edge can be seen as a
  split $S=A|B$, e.g. the cyan edge is the split $S = \{A, B\} | \{C\}$.}
  \label{fig:exampleTree}
\end{figure}

Phylogenetic trees are widely used to communicate evolutionary relationships
between species
\cite{mandalComparativeGenomeAnalysis2022,winkworthComparativeAnalysesComplete2022,ayala-usmaWholeGenomeDuplication2021}.
They are one of multiple different types type of \textit{phylogenetic networks}
\cite{husonApplicationPhylogeneticNetworks2006}. Depending on the use case, one
might choose a different kind of phylogenetic network to communicate
evolutionary relationships, e.g. \textit{splits networks} or
\textit{hybridization networks}. This is especially useful when one needs to
include evolutionary events such as horizontal gene transfer or hybridization,
which are not supported by phylogenetic trees as displaying those implies
displaying loops. 

The Neighbor-Net algorithm \cite{bryantNeighborNetAgglomerativeMethod2004} is
one algorithm to construct a phylogenetic network. In the most recent version,
it works by finding a circular ordering of the taxa $X$ based on a distance matrix
$D$, calculating all splits $\Sigma$ that are compatible to that ordering and
estimating their weights \cite{bryantNeighborNetImprovedAlgorithms2023}. 

$\Sigma$ as calculated by Neighbor-Net contains $\mathcal{O}(n^2)$ splits
\cite{bryantNeighborNetImprovedAlgorithms2023}. Those splits could already be
displayed as a valid phylogenetic network, however this introduces
$\mathcal{O}(n^4)$ edges and internal nodes
\cite{bagciMicrobialPhylogeneticContext2021} that are hard to interpret.
Phylogenetic outlines provide a simplification of that by replacing internal
edges and internal nodes with a single polygon that only keeps the outermost
edges and outermost internal nodes \cite{bagciMicrobialPhylogeneticContext2021}.
In such a network, each split is either visualised by a single edge or by a pair
of parallel edges. An example of such a phylogenetic outline can be seen in
Figure~\ref{fig:outlineExample}. 

\begin{figure}
  \centering
  \begin{tikzpicture}[node distance={10mm}, minimum size={2mm}, inner
    sep={0pt}, thick, main/.style = {draw, circle, fill},
    color_edge/.style = {color=cyan}]
    \node[](l0){};
    \node[below = of l0](l1){};
    \node[below = of l1](l2){};
    \node[below = of l2](l3){};
    \node[below = of l3](l4){};

    \node[main, right = 20mm of l0](root){};
    \node[main, right = 20mm of l1](i1){} edge(root);
    \node[main, right = 10mm of l2](i2){} edge[color_edge](i1);
    \node[main, right = 30mm of l2](i4){} edge(i1);
    \node[main, right = 20mm of l3](i3){} edge(i2) edge[color_edge](i4);

    \node[right = 0mm of l2](a) {A} edge(i2);
    \node[right = 20mm of l4](b) {B} edge(i3);
    \node[right = 40mm of l2](c) {C} edge(i4);
  \end{tikzpicture}
  \caption[Example of a rooted phylogenetic outline]{Example of a rooted
  phylogenetic outline on the taxa $X = \{A, B, C\}$. The outer nodes are
  labeled with the taxa, the internal nodes don't have labels. In this example,
  each edge and each pair of parallel edges can be seen as a split, e.g. the
  cyan edges depict the split $S = \{A, B\} | \{C\}$.}
  \label{fig:outlineExample}
\end{figure}

\section{Phylogenetic research on \textit{Phytophthora}} 

The first scientific publication on \textit{Phytophthora} was made in 1876 by
\Citeauthor{debaryResearchesNaturePotatofungus1876}
\cite{debaryResearchesNaturePotatofungus1876,kroonGenusPhytophthoraAnno2012}.
Since then, extensive research has been conducted on a variety of aspects about
this genus. Initially, as indicated by the title of the publication by
\Citeauthor{debaryResearchesNaturePotatofungus1876}, members of
\textit{Phytophthora} were thought to be fungi, but the genus is now classified
in the Phylum Pseudofungi within the kingdom Chromista
\cite{hardhamPhytophthoraCinnamomi2018,beakesEvolutionaryPhylogenyOomycete2012}.

There are many revisions of \textit{Phytophthora} phylogeny, e.g.
\cite{kroonGenusPhytophthoraAnno2012,yangExpandedPhylogenyGenus2017,abadPhytophthoraTaxonomicPhylogenetic2023a}.
Typically, the genus is divided into multiple clades, each with a numerical
identifier. The exact number and relationsips of the clades is different from
publication to publication. This thesis compares the topologies of the generated
trees with literature, so it is useful to state their Newick strings here:

\begin{itemize}
  \item \Citeauthor{kroonGenusPhytophthoraAnno2012} state the following topology:\\
    \texttt{((((((((1, 4), 2), 5), 3), 6), 7), 8), (9, 10))}\cite{kroonGenusPhytophthoraAnno2012}
  \item \Citeauthor{yangExpandedPhylogenyGenus2017} state the following topology:\\
    \texttt{((((((((1, 4), 2), 3), 5), 7), 6), 8), (9, 10))}\cite{yangExpandedPhylogenyGenus2017}
  \item \Citeauthor{abadPhytophthoraTaxonomicPhylogenetic2023a} state the following topolgy:\\
    \texttt{(((((((((1, 2), (12, 4)), (3, 13)), 5), 6), 7), 11), 8), (9, 10))}\cite{abadPhytophthoraTaxonomicPhylogenetic2023a}
\end{itemize}

Given the rise of modern sequencing techniques, and thus the increased abundance
of available genomic data, more and more studies are also comparing different
aspects of \textit{Phytophthora} genomes, e.g. the location and content of
transposable elements and simple sequence repeats
\cite{mandalComparativeGenomeAnalysis2022}, the evolution of mitogenome
sequences involving other Peronosporaceae genomes
\cite{winkworthComparativeAnalysesComplete2022}, the diversity of
\textit{Phytophthora} genomes found in soil and water samples
\cite{catalaUseGenusSpecificAmplicon2015} or the differences in species
communities associated with soy beans
\cite{navarroComparisonSpeciesCommunities2021}.

The findings include that some \textit{Phytophthora} species are
hybrids, e.g. \textit{Phytophthora $\times$cambivora}
\cite{jungSixNewPhytophthora2017,vanpouckeUnravellingHybridizationPhytophthora2021}.
Given this information, using phylogenetic networks over phylogenetic trees
might be a sensible thing to do.

Also of interest is the concept of the two-speed genome model. Under model, some
\textit{Phytophthora} genomes have regions with diverging evolutionary rates,
i.e. the regions containing the household genes evolve slower than those regions
containing the effector genes \cite{dongTwospeedGenomesFilamentous2015}. The
fast evolving regions are gene sparse and repeat rich, the latter seems to
enable faster evolution on a molecular level with repeat induced point mutations
\cite{dongTwospeedGenomesFilamentous2015}. There is evidence for this model for
various \textit{Phytophthora} species including \textit{Phytophthora cinnamomi}
\cite{engelbrechtGenomeDestructiveOomycete2021} and \textit{Phytophthora
infestans}
\cite{ayala-usmaWholeGenomeDuplication2021,dongTwospeedGenomesFilamentous2015},
but there is also evidence that not all \textit{Phytophthora} species have this
genome architecture, e.g. \textit{Phytophthora betacei}
\cite{ayala-usmaWholeGenomeDuplication2021}.

\textit{Phytophthora cinnamomi} and \textit{Phytophthora infestans} receive lots
of attention because of their impact on wildlife and agriculture:
\textit{Phytophthora cinnamomi} is reported to target over 5000 different hosts
such as avocado trees in Europe and natural vegetation in Australia
\cite{hardhamPhytophthoraCinnamomi2018,solis-garciaPhytophthoraRootRot2020},
\textit{Phytophthora infestans} is most famously known for its devestating
impact on potatoes and tomatoes \cite{ayala-usmaWholeGenomeDuplication2021}.


\section{Mash}
The phylogenies discussed above are expensive both in terms of labor and in
terms of computation: typical approaches include the prediction of conserved
genes, the alignment of the corresponding sequences and then the inference of a
phylogenetic tree, for example using bayesian inference
\cite{abadPhytophthoraTaxonomicPhylogenetic2023a,winkworthComparativeAnalysesComplete2022}.

In contrast to them, the methods used in this thesis, namely Neighbor-Joining
and the Neighbor-Net algorithm for tree and network construction, respectively,
rely on distance matrices for the involved taxa
\cite{saitouNeighborjoiningMethodNew1987,bryantNeighborNetImprovedAlgorithms2023,bryantNeighborNetAgglomerativeMethod2004}.
One could obtain such a distance matrix, e.g. by utilizing the average
nucleotide identiy (ANI) \cite{leeOrthoANIImprovedAlgorithm2016}. However, this
in turn introduces computational cost and is not suited for distantly related
species.

Another method, Mash, estimates the evolutionary distance by utilizing a concept
from web search engines from the early days of the internet: MinHash
\cite{broderResemblanceContainmentDocuments1998a,ondovMashFastGenome2016}. While
this method is about estimating the similarity between two different documents
on the world wide web, \Citeauthor{ondovMashFastGenome2016} applied the concept
to nucleotide sequences.

Let $A = a_1 a_2 \dots a_l$ be a string with length $l$ on the DNA alphabet with
$a_i = \{A, T, G, C\}$. $A$ can be decomposed into a set containing all
substrings of length $k$, so called $k$-mers, using $k(A) = \{a_i \dots
a_{i+k-1} | 1 \leq i < l-k-1\}$. Using a \textit{hash function} $h: \Omega
\rightarrow [0, H]$ with typically $H=2^{64}$ or $H=2^{128}$ on modern
computers, one can obtain the \textit{hash value} $h(i)$ for each such $k$-mer.
For the sequence $A$ the \textit{Mash sketch} $S(A)$ is the set of the
$s_{mash}$ smallest $h(i) ~ \forall i \in k(A)$. Note that the parameter
$s_{mash}$ is called $s$ in the original Mash publication
\cite{ondovMashFastGenome2016}, but as there is a parameter  with the same name
but different semantics in FracMinHash, I denote it as $s_{mash}$. As an
example, consider the sequence $A=ATGCCCA$. For $k=4$, $k(A) = \{ATGC, TGCC,
GCCC, CCCA\}$. Let's assume a hash function has generated hash values
$h(i)~\forall i \in k(A)$ and let's call this set $h(A) = \{12, 1, 13, 7\}$.
With $s_{mash}=2$, we keep the two smallest hash values and obtain $S(A) = \{1,
7\}$ as the Mash sketch. Assume now the sequence $A$ is longer, i.e. $k(A)$
contains more $k$-mers. We would process the next $k$-mer in the set and
calculate its hash value. If the hash value is below $7$, we would need to
update the sketch by removing $7$ and adding the new hash value.

One can use the sketches of two genomes $A$ and $B$ to estimate the Jaccard
similarity with 

\begin{align}
  J(A, B) = \frac{|A \cap B|}{|A \cup B|} \approx \frac{|S(A \cup B) \cap S(A) \cap S(B)|}{|S(A) \cup S(B)|}
\end{align}

The error of this estimation is bounded by $\epsilon =
\mathcal{O}(\frac{1}{\sqrt{s_{mash}}})$ \cite{ondovMashFastGenome2016}. The
similarity estimation can then be used to obtain a measure of distance with

\begin{align}
  D_{mash}(A,B) = -\frac{1}{k}\ln{\frac{2J(A,B)}{1+J(A,B)}}
\end{align}

This method is widely used in different applications. In the original
publication, the authors created Mash sketches for all RefSeq genomes, estimated
the distances based on those and calcualted an evolutionary tree
\cite{ondovMashFastGenome2016}. Mash is also incorporated into FastANI to
estimate ANI scores \cite{jainHighThroughputANI2018}.

A third use case for Mash is the creation of phylogenetic contexts using
phylogenetic outlines \cite{bagciMicrobialPhylogeneticContext2021} in
metagenomic studies. In this context, one sequences all DNA found in a given
sample, e.g. soil or sea water, and assembles (draft) genomes from the acquired
reads \cite{kuninBioinformaticianGuideMetagenomics2008}. The phylogenetic
context is established by placing the draft genome in a phylogenetic outline
using all sequences from a reference databases that have a Mash distance to the
query below a user defined threshold
\cite{bagciMicrobialPhylogeneticContext2021}.

Mash itself is implemented in a tool called \texttt{mash}
\cite{ondovMashFastGenome2016}. For convenience, there exists also a tool called
\texttt{mashtree} \cite{katzMashtreeRapidComparison2019} which utilizes Mash to
directly calculate distances and a phylogenetic tree given some input sequences.

\section{FracMinHash}
Mash is not the only method in the area of \textit{locality sensitive hashing}.
A recently published method is called FracMinHash by
\Citeauthor{irberLightweightCompositionalAnalysis2022}
\cite{irberLightweightCompositionalAnalysis2022} and aims to tackle some of the
issues of Mash, namely containment estimation and distance estimation for
genomes with different sizes
\cite{heraDerivingConfidenceIntervals2023,koslickiImprovingMinHashContainment2019}.

The key idea of FracMinHash is to define a threshold $\frac{H}{s}$ with $H$
being the largest value that $h$ can produce and $s$ a user defined scaling
parameter with $0 < s \leq H$ such that a FracMinHash sketch only contains hash
values below that threshold. As shown in Section~\ref{sec:res}, the sketch size
can be approximated by $\frac{n}{s}$ where $n$ is the size of the input sequence
\cite{irberLightweightCompositionalAnalysis2022,heraDerivingConfidenceIntervals2023}.


Formally, the FracMinHash sketch is defined as 

\begin{align}
  \mathbf{FRAC}_s(A) = \{h(i) \leq \frac{H}{s} | \forall i \in k(A)\}
\end{align}

Let's reconsider the example from the Mash section with the sequence
$A=ATGCCCA$. For $k=4$, $k(A) = \{ATGC, TGCC, GCCC, CCCA\}$. Let's assume a hash
function has generated hash values $h(i)~\forall i \in k(A)$ and let's call this
set $h(A) = \{12, 1, 13, 7\}$. Assume that $H=2^4-1=15$ and $s=2$, we keep all
hashes that satisfy $h(i) \leq \frac{15}{2}=7.5$ and obtain $\mathbf{FRAC}_s(A)
= \{1, 7\}$ as the FracMinHash sketch. Again, let us assume now that $A$ is
longer and $k(A)$ contains more $k$-mers. When we process the next $k$-mer in
this set and calculate it's hash value, we only need to check if it is below the
threshold of $7.5$, irregardless of the content of the FracMinHash sketch. This
enables FracMinHash to operate on streams.

In Mash, to estimate the Jaccard index, it is required to also find the
$s_{mash}$ smallest overall hashes of the two input sequences, i.e. $S(A \cup
B)$. This is not needed for FracMinHash, as all hashes that are part of the
input sketches already satisfy the condition $h(i) \leq \frac{H}{s}$. Thus, the
Jaccard estimation (including a factor correcting for bias) is given in
\cite{heraDerivingConfidenceIntervals2023} as

\begin{align}
  J_{frac} = \frac{\hat{J}_{frac}}{1 - (1 - s)^{|A \cup B|}}
\end{align}

with

\begin{align}
  \hat{J}_{frac}(A, B) = \frac{|\mathbf{FRAC}_s(A) \cap \mathbf{FRAC}_s(B)|}{|\mathbf{FRAC}_s(A) \cup \mathbf{FRAC}_s(B)|}  
\end{align}

This Jaccard index can be used to calculate evolutionary distances, for which
the FracMinHash publications follow again an approach different to Mash. Mash
uses a Poisson model that assumes that all $k$-mers mutate independently
\cite{ondovMashFastGenome2016,heraDerivingConfidenceIntervals2023,fanAssemblyAlignmentfreeMethod2015},
whereas FracMinHash assumes a simple model in which each nucleotide $a_i$ of a
sequence $A$ mutates at a fixed rate $p$
\cite{heraDerivingConfidenceIntervals2023}. The authors note that such a mutated
sequence $A'$ has an ANI of $1-p$ to $A$. As the inverse can be used to
calculate a distance from any similarity ($D = 1 - I$), I will denote $p$ in the
following as $D_{frac}$. Following this, the authors define an estimation of the
distance in \cite{heraDerivingConfidenceIntervals2023} as

\begin{align}
  D_{frac}(A, B) = 1 - (\frac{2J_{frac}(A,B)}{1+J_{frac}(A, B)})^{\frac{1}{k}}
\end{align}

FracMinHash also defines a containment index and the corresponding distance for
which the publication by \Citeauthor{heraDerivingConfidenceIntervals2023}
derives confidence intervals \cite{heraDerivingConfidenceIntervals2023}. For the
context of this thesis, those confidence intervals do not play a role in
calculating the phylogenies.

\begin{align}
  C_{frac}(A, B) = \frac{|\mathbf{FRAC}_S(A) \cap \mathbf{FRAC}_s(B)|}{|\mathbf{FRAC}_S(A)| (1-(1-s)^{|A|})}
\end{align}
\begin{align}
  D=1-C_{frac}^{\frac{1}{k}}
\end{align}


FracMinHash is implemented in a tool called \texttt{sourmash}
\cite{irberLightweightCompositionalAnalysis2022,irberDecentralizingIndicesGenomic2020}.
For the purpose of this thesis, I have implemented the method in
\texttt{fmhdist} to obtain phylogenetic outlines as described in
\cite{bagciMicrobialPhylogeneticContext2021}.
